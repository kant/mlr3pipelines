% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PipeOpCopy.R
\docType{data}
\name{mlr_pipeops_copy}
\alias{mlr_pipeops_copy}
\alias{PipeOpCopy}
\title{PipeOpCopy}
\format{\code{\link{R6Class}} object inheriting from \code{\link{PipeOp}}.}
\description{
Copies its input \code{outnum} times. This PipeOp usually not needed,
because copying happens automatically when one \code{PipeOp} is followed
by multiple different \code{PipeOp}s. However, when constructing big
Graphs using the \code{\link{\%>>\%}}-operator, \code{PipeOpCopy} can be helpful to
specify which \code{\link{PipeOp}} gets connected to which.
}
\section{Construction}{
\preformatted{PipeOpEnsemble$new(outnum, id = "copy", param_vals = list())
}
\itemize{
\item \code{outnum} :: \code{numeric(1)}\cr
Number of output channels, and therefore number of copies being made.
Identifier of resulting object, default \code{"copy"}.
\item \code{param_vals} :: named \code{list}\cr
List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise be set during construction. Default \code{list()}.
}
}

\section{Input and Output Channels}{

\code{\link{PipeOpCopy}} has one input channel named \code{"input"}, taking any input (\code{"*"}) both during training and prediction.

\code{\link{PipeOpCopy}} has multiple output channels depending on the \code{outnum} construction argument, named \code{"output1"}, \code{"output2"}, ...
All output channels produce the object given as input (\code{"*"}).
}

\section{State}{

The \code{$state} is left empty (\code{list()}).
}

\section{Parameters}{

\code{\link{PipeOpCopy}} has no parameters.
}

\section{Internals}{

Note that copies are not clones, but only reference copies. This affects
R6-objects: If R6 objects are copied using PipeOpCopy, they must be cloned
before
}

\section{Fields}{

Only fields inherited from \code{\link{PipeOp}}.
}

\section{Methods}{

Only methods inherited from \code{\link{PipeOp}}.
}

\examples{
# The following copies the output of 'scale' automatically to both
# 'pca' and 'nop'
mlr_pipeops$get("scale") \%>>\%
  gunion(list(
    mlr_pipeops$get("pca"),
    mlr_pipeops$get("nop")
  ))

# The following would not work: the '\%>>\%'-operator does not know
# which output to connect to which input
# > gunion(list(
# >   mlr_pipeops$get("scale"),
# >   mlr_pipeops$get("select")
# > )) \%>>\%
# >   gunion(list(
# >     mlr_pipeops$get("pca"),
# >     mlr_pipeops$get("nop"),
# >     mlr_pipeops$get("impute")
# >   ))
# Instead, the 'copy' operator makes clear which output gets copied.
gunion(list(
  mlr_pipeops$get("scale") \%>>\% mlr_pipeops$get("copy", outnum = 2),
  mlr_pipeops$get("select")
)) \%>>\%
  gunion(list(
    mlr_pipeops$get("pca"),
    mlr_pipeops$get("nop"),
    mlr_pipeops$get("impute")
  ))
}
\seealso{
Other PipeOps: \code{\link{PipeOpEnsemble}},
  \code{\link{PipeOpTaskPreproc}}, \code{\link{PipeOp}},
  \code{\link{mlr_pipeops_branch}},
  \code{\link{mlr_pipeops_chunk}},
  \code{\link{mlr_pipeops_classbalancing}},
  \code{\link{mlr_pipeops_classifavg}},
  \code{\link{mlr_pipeops_colapply}},
  \code{\link{mlr_pipeops_encode}},
  \code{\link{mlr_pipeops_featureunion}},
  \code{\link{mlr_pipeops_filter}},
  \code{\link{mlr_pipeops_impute}},
  \code{\link{mlr_pipeops_learner}},
  \code{\link{mlr_pipeops_mutate}},
  \code{\link{mlr_pipeops_nop}},
  \code{\link{mlr_pipeops_pca}},
  \code{\link{mlr_pipeops_regravg}},
  \code{\link{mlr_pipeops_scale}},
  \code{\link{mlr_pipeops_select}},
  \code{\link{mlr_pipeops_subsample}},
  \code{\link{mlr_pipeops_unbranch}},
  \code{\link{mlr_pipeops}}

Other Placeholder Pipeops: \code{\link{mlr_pipeops_nop}}
}
\concept{PipeOps}
\concept{Placeholder Pipeops}
\keyword{datasets}
